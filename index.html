<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Цифровая демографическая обсерватория: прогноз показателей субъектов РФ до 2100 г.</title>
  <!-- Plotly для графиков, PapaParse для CSV, SheetJS для XLSX -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{
      --bg:#ffffff; --fg:#111; --muted:#666; --grid:#e7e7e7; --accent:#1f77b4; --accent2:#d62728; --accent3:#2ca02c; --accent4:#9467bd; --accent5:#ff7f0e;
    }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    header{padding:16px 20px;border-bottom:1px solid var(--grid)}
    h1{margin:0 0 4px 0;font-size:22px;font-weight:500}
    .sub{color:var(--muted);font-size:14px;max-width:900px}
    main{max-width:1240px;margin:0 auto;padding:16px}
    .panel{display:grid;grid-template-columns:2fr 1fr;gap:12px;margin-bottom:12px;align-items:start}
    .card{border:1px solid var(--grid);border-radius:12px;padding:14px;background:#fafafa;box-shadow:0 2px 6px rgba(0,0,0,.04)}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    select, input[type="range"], button{width:100%;padding:8px;border:1px solid var(--grid);border-radius:10px;background:#fff;font-size:14px}
    button{cursor:pointer;transition:all .15s ease;border-color:#dcdcdc}
    button:hover{background:#f2f2f2}
    .row{display:grid;grid-template-columns:repeat(3, 1fr);gap:12px}
    .charts{display:grid;grid-template-columns:1fr;gap:18px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:18px}
    .small{font-size:12px;color:var(--muted)}
    .legend-pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--grid);margin-right:6px;font-size:12px}
    .err{color:#b00020;font-size:13px}
    footer{max-width:1240px;margin:24px auto 32px auto;padding:0 16px;color:var(--muted);font-size:12px;text-align:right}
    #logBox{margin-top:16px;white-space:pre-line}
    .card-header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    .card-header h3{margin:0;font-size:18px;font-weight:600;color:#222}
    .card-header .eyebrow{color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.05em;margin-bottom:3px}
    .card-actions{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .pill-row{display:flex;align-items:center;gap:12px;flex-wrap:wrap;font-size:13px;color:var(--muted)}
    .control-inline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .control-inline select{width:auto;min-width:180px}
    .control-inline label{margin:0;display:flex;align-items:center;gap:6px}
    .plot{height:100%}
    .tall{min-height:460px}
    .mid{min-height:360px}
    .slim{min-height:320px}
    .methods details{margin-bottom:10px;border:1px solid var(--grid);border-radius:10px;padding:10px;background:#fff}
    .methods summary{font-weight:600;cursor:pointer}
    .method-text{white-space:pre-wrap;font-family:inherit;line-height:1.5;font-size:14px;margin:8px 0 0 0}
    @media (max-width:900px){
      .panel{grid-template-columns:1fr}
      .grid2{grid-template-columns:1fr}
      .card-header{flex-direction:column;align-items:flex-start}
      .card-actions{width:100%;justify-content:flex-start}
    }
  </style>
</head>
<body>
<header>
  <h1>Цифровая демографическая обсерватория: прогноз показателей субъектов РФ до 2100 г.</h1>
  <div class="sub">
    Исследование выполнено за счёт средств гранта Российского научного фонда № 25-78-30004
    «Цифровая демографическая обсерватория: разработка системы мониторинга демографических процессов
    в регионах России с использованием ГИС-технологий и больших данных», https://rscf.ru/project/25-78-30004/
  </div>
</header>
<main>
  <div class="panel">
    <div class="card">
      <label for="territorySel">Субъект Российской Федерации</label>
      <select id="territorySel"></select>
    </div>
  </div>

  <div class="charts">
    <div class="card tall">
      <div class="card-header">
        <div>
          <div class="eyebrow">Долгосрочный прогноз</div>
          <h3>Общая численность населения, человек</h3>
        </div>
        <div class="card-actions">
          <button id="btnPopPNG">PNG</button>
          <button id="btnPopXLSX">XLSX</button>
        </div>
      </div>
      <div id="chartPop" class="plot" style="height:430px"></div>
    </div>

    <div class="grid2">
      <div class="card mid">
        <div class="card-header">
          <div>
            <div class="eyebrow">Рождаемость</div>
            <h3>Суммарный коэффициент рождаемости, детей на женщину</h3>
          </div>
          <div class="card-actions">
            <button id="btnTFRPNG">PNG</button>
            <button id="btnTFRXLSX">XLSX</button>
          </div>
        </div>
        <div id="chartTFR" class="plot" style="height:320px"></div>
      </div>
      <div class="card mid">
        <div class="card-header">
          <div>
            <div class="eyebrow">Ожидаемая продолжительность жизни</div>
            <h3>ОПЖ при рождении, лет</h3>
          </div>
          <div class="card-actions">
            <button id="btnLEPNG">PNG</button>
            <button id="btnLEXLSX">XLSX</button>
          </div>
        </div>
        <div id="chartLE" class="plot" style="height:320px"></div>
      </div>
    </div>

    <div class="card mid">
      <div class="card-header" style="flex-wrap:wrap; gap:16px">
        <div>
          <div class="eyebrow">Миграция населения</div>
          <h3>Миграционное сальдо и потоки, человек</h3>
        </div>
        <div class="control-inline" style="margin-left:auto">
          <label><input type="checkbox" id="chkMigMale" checked> Мужчины</label>
          <label><input type="checkbox" id="chkMigFem" checked> Женщины</label>
          <label><input type="checkbox" id="chkMigTot" checked> Всего</label>
        </div>
        <div class="card-actions">
          <button id="btnMigPNG">PNG</button>
          <button id="btnMigXLSX">XLSX</button>
        </div>
      </div>
      <div id="chartMIG" class="plot" style="height:360px"></div>
    </div>

    <div class="card mid">
      <div class="card-header" style="flex-wrap:wrap;gap:14px">
        <div>
          <div class="eyebrow">Структура населения</div>
          <h3>Половозрастная пирамида, человек</h3>
        </div>
        <div class="control-inline">
          <label for="scenarioSel">Сценарий численности населения</label>
          <select id="scenarioSel">
            <option value="withMIG">С учётом миграции</option>
            <option value="noMIG">Без миграции</option>
          </select>
        </div>
        <div class="control-inline" style="flex:1;min-width:260px">
          <label for="yearRange" style="flex:0 0 auto">Год:</label>
          <input id="yearInput" type="number" min="2017" max="2100" step="1" value="2025" style="width:100px"/>
          <input id="yearRange" type="range" min="2017" max="2100" step="1" value="2025" style="flex:1"/>
        </div>
        <div class="card-actions">
          <button id="btnPyrPNG">PNG</button>
          <button id="btnPyrXLSX">XLSX</button>
        </div>
      </div>
      <div id="chartPYR" class="plot" style="height:430px"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-header">
      <div>
        <div class="eyebrow">Методические материалы</div>
        <h3>Авторские методики расчёта прогнозов</h3>
      </div>
    </div>
    <div class="methods">
      <details>
        <summary>Суммарный коэффициент рождаемости</summary>
        <pre class="method-text">Методика прогноза суммарного коэффициента рождаемости (СКР) до 2100 года
(Российская Федерация, федеральные округа, все субъекты; годовая шкала 1990–2100)
1. Исходные данные и цель расчёта
Вход представляет собой прямоугольную панель годовых значений СКР по всем строкам исходного файла «Суммарный коэффициент рождаемости 1990–2024.xlsx» (лист «Данные»), где первый столбец содержит наименование территории, а последующие столбцы — годы наблюдений. Для каждой территории используется вся доступная история за 1990–2024 годы; пропуски в наблюдениях приводятся к числовому формату с мягкой интерполяцией только внутри наблюдаемого интервала при единичных разрывах. Целью является построение годовых прогнозов до 2100 года с волнообразной динамикой, реалистичной для посттранзитной фертильности, без навязанных «нормативных» подъёмов и без плоских траекторий.
2. Общая схема моделирования
Метод включает два статистически строгих компонента, объединённых ансамблированием. Первый компонент — гауссов процесс регрессии (Gaussian Process Regression, GPR) на времени с композиционным ядром «тренд + гладкость + периодика», позволяющий извлекать и продолжать сглаженные циклы/полуциклы, типичные для динамики СКР. Используются ядра RationalQuadratic и ExpSineSquared в сумме с линейным ядром DotProduct и шумовой компонентой; предсказание возвращает не только условное среднее, но и дисперсию, что позволяет формировать доверительные интервалы по годам. Теория и реализация GPR, а также параметризация периодического ядра ExpSineSquared детально описаны в руководстве scikit-learn; документация по классу GaussianProcessRegressor и ядрам служит основным техническим источником. 
Второй компонент — структурная модель не наблюдаемых компонент (Unobserved Components, UCM) со стохастическим затухающим циклом и локальным уровнем, оцениваемая в формате state space с фильтром Калмана; именно UCM обеспечивает экономическую интерпретируемость циклической части и корректную экстраполяцию медленных колебаний. Конструкция и опции модели (включая cycle, stochastic_cycle, damped_cycle) формально определены в документации statsmodels и восходят к классике структурных рядов Харви. 
3. Детали статистической постановки
Для каждой территории iнаблюдается годовой ряд y_{i,t}на сетке t\in{1990,\ldots,2024}. Гауссов процесс задаётся нулевым средним и суммой ядер k(t,t^\prime)=k_{\mathrm{lin}}+k_{\mathrm{RQ}}+k_{\mathrm{per}}+k_{\mathrm{noise}}, где k_{\mathrm{lin}}— DotProduct, k_{\mathrm{RQ}}— RationalQuadratic (многошкальная гладкость), k_{\mathrm{per}}— ExpSineSquared с периодичностью порядка 7–15 лет, которая уточняется по максимуму маргинального правдоподобия. Такая композиция позволяет совместно описывать медленные тренды, сглаженную неровность и периодические колебания; формулы и свойства ядер приведены в официальной документации. 
Структурная модель записывается как y_{i,t}=\mu_{i,t}+\psi_{i,t}+\varepsilon_{i,t}, где \mu_{i,t}— локальный уровень (local level), \psi_{i,t}— стохастический затухающий цикл, \varepsilon_{i,t}\sim\mathcal{N}(0,\sigma^2). Идентификация и оценивание выполняются стандартными средствами UCM; опции стохастичности и демпфирования циклической компоненты соответствуют руководству statsmodels и монографии Харви. 
4. Оценивание, валидация и ансамблирование
Оценивание гиперпараметров ГП проводится по максимуму маргинального правдоподобия с перекрёстной проверкой, адаптированной к временным рядам (TimeSeriesSplit): обучающие блоки последовательно расширяются, тестовые блоки расположены в будущем относительно обучающих, что предотвращает утечки информации. Данный подход и интерфейс валидатора описаны в документации scikit-learn. Для каждого ряда строится предиктивное распределение ГП на сетке 1990\ldots2100, извлекаются квантили p={2,5;\mathrm{\thinsp}10;\mathrm{\thinsp}50;\mathrm{\thinsp}90;\mathrm{\thinsp}97,5}. Параллельно на том же ряду оценивается UCM, откуда извлекается точечный прогноз медианного уровня. Далее формируется взвешенная медиана: на ближнем горизонте до опорного года T_{\mathrm{blend}}больший вес получает ГП (что сохраняет эмпирическую волнообразность последних лет), после чего вес плавно трансформируется к усреднению ГП и UCM; переход задаётся непрерывной весовой функцией по годам прогноза. Такая конструкция обеспечивает устойчивость к переобучению и интерпретируемость циклов. Для предотвращения нефизиологичных значений на дальнем горизонте применяется мягкая цензура, индивидуальная для каждой территории: нижняя граница \max\funcapply{0,5,\min\funcapply(y)-0,25}, верхняя \min\funcapply{5,0,\max\funcapply(y)+0,75}.
Отдельно используется контроль вариативности: для ближайшего интервала прогнозирования проверяется, что стандартное отклонение медианной траектории по годам положительно; обнаружение патологически «плоских» сегментов инициирует пересмотр сетки периодов периодического ядра, что методологически согласуется с практикой настройки GP-ядер и структурных циклов. Теоретические основания корректности указанных инструментов заданы в руководствах scikit-learn и statsmodels и в классических источниках по GP и структурным моделям. 
5. Различия с байесовской методологией ООН и мотивация выбора
Байесовская иерархическая модель ООН (bayesTFR) в посттранзитной фазе априорно моделирует флуктуации вокруг уровня воспроизводства и на длинном горизонте имеет восходящий дрейф медианы к ≈2,1; в условиях последних лет с падением СКР это даёт систематический подъём ближайших прогнозных значений при сшивке на 2022–2023 годах национального объекта. Применённая здесь ML-схема не навязывает конвергенцию к replacement, допускает продолжение нисходящих волн и одновременно удерживает гладкость и интерпретируемость циклов через структурный компонент. Это и стало причиной выбора гибридной GP+UCM для оперативной прикладной постановки; формальные определения используемых моделей и инструментов доступны в официальной документации упомянутых библиотек и классических источниках. 
6. Воспроизводимость и программные реалии
Расчёт реализован в Google Colab на Python. Для ГП использованы GaussianProcessRegressor и ядра RationalQuadratic, ExpSineSquared, DotProduct, WhiteKernel; для структурной модели — statsmodels.tsa.statespace.structural.UnobservedComponents. Валидация выполнена с помощью TimeSeriesSplit без перемешивания, как рекомендовано для временных рядов. Фиксирован random_state=42 при оптимизации гиперпараметров; получаемые результаты детерминированны с точностью до численной оптимизации. Подробное описание API и свойств используемых классов приведено в официальной документации scikit-learn и statsmodels. 
7. Результирующие файлы и структура полей
Итоговая выгрузка представлена в двух форматах. Первая — «tidy»-база, где каждая запись соответствует уникальной паре «территория–год», со следующими полями: «Территория» (строго из исходного файла), «Год» (1990–2100), «median» (медианный прогноз или наблюдаемое значение в истории), «q10», «q90», «q2_5», «q97_5» (границы 80% и 95% предиктивных интервалов из ГП), «Статус» («наблюдение» для 1990–последний год фактических данных включительно; «прогноз» для последующих лет до 2100). Вторая — «wide»-база, где по строкам годы, по столбцам территории; файл содержит лист «median» (матрица медианных значений) и лист «status» (матрица статусов «наблюдение/прогноз»). Имена файлов в поставке следующие: «TFR_Russia_subjects_ML_GP_UCM_tidy.csv» и «TFR_Russia_subjects_ML_GP_UCM_tidy.xlsx» (база в длинном формате) и «TFR_Russia_subjects_ML_GP_UCM_wide.xlsx» (широкий формат). Эти файлы полностью согласованы по годам и территориям, не содержат пропусков в прогнозной части и готовы для дальнейшей интеграции в аналитические витрины.
8. Методические ограничения и направления развития
Медианные траектории основаны на ГП-приближении нормального предиктивного распределения; в узких выборках с сильными структурными сдвигами интервалам может потребоваться уточнение на основе бутстреп-симуляций из структуральной модели. Компонент UCM идентифицирует один затухающий цикл; при наличии дополнительных частотных мод может понадобиться альтернативная спецификация циклического блока. При доступности возрастно-специфических коэффициентов рождаемости (ASFR) корректно перейти к функционально-данным моделям с когерентностью по субпопуляциям; в отсутствие ASFR текущая постановка обеспечивает требуемую волнообразность на годовой шкале при строгом контроле гладкости и правдоподобия уровней. Теоретические и программные основания применённых инструментов задокументированы в публичных руководствах и классических источниках по структурным моделям и гауссовым процессам. </pre>
      </details>
      <details>
        <summary>Ожидаемая продолжительность жизни</summary>
        <pre class="method-text">Прогноз ожидаемой продолжительности жизни при рождении до 2100 года 
(Российская Федерация, федеральные округа, все субъекты; по полу: женщины, мужчины)
Полная база представлена в БД-формате и в широком формате, добавлен диагностический файл с параметрами модели по каждой строке. Файлы:
БД-версия (все наблюдения и прогнозы на каждый год, без пропусков): LE_Russia_subjects_forecast_2100_long.xlsx, CSV
Широкий формат (лист values — значения, лист status — статус «наблюдение/прогноз»): LE_Russia_subjects_forecast_2100_wide.xlsx
Диагностика (якорный уровень y_0, оценённый доковидный наклон s_0, асимптота L, скорость затухания k, год якоря): LE_Russia_subjects_forecast_2100_diagnostics.csv
В качестве основы использована согласованная по всем строкам ограниченная логистическая экстраполяция. Для каждого территориально-полового ряда берётся якорный уровень y_0за 2023 год и оценивается среднесрочная скорость прироста s_0на доковидном участке устойчивого роста 2004–2019 гг. простейшей OLS-регрессией y_t=\alpha+\beta t\ при исключении 2020–2021 гг. как экзогенного шока; при дефиците наблюдений задействуются расширенные окна и, в крайнем случае, национальный «бенчмарк»-наклон. Дальнейшая траектория строится по формуле
y(t)=L-(L-y_0)\exp\funcapply{-k\mathrm{\thinsp}(t-2023)},k=\frac{s_0}{L-y_0},t\geq2023,
что обеспечивает монотонный рост и демпфирование к реалистичным потолкам без артефактов неограниченной линейной экстраполяции. Верхние пределы заданы унифицированно по полу: для женщин L=92, для мужчин L=88лет; для каждого ряда дополнительно гарантируется L>y_0. Исторические значения 1990–2023 гг. сохраняются в исходном виде, а статус «наблюдение/прогноз» явно помечен в выдаче.
База данных включает полный годовой ряд 1990–2100 для каждой строки исходного файла; в «tidy»-версии поля: «Территория», «Пол», «Год», «e0», «Статус». Если потребуется, могу оперативно пересчитать сценарии с альтернативными потолками L\ (консервативный/оптимистичный), добавить доверительные интервалы (бутстреп вокруг логистики) либо агрегировать по полу в «оба пола» при наличии согласованных весов.</pre>
      </details>
      <details>
        <summary>Миграционный приток, отток и сальдо</summary>
        <pre class="method-text">Методика прогноза миграционного притока, оттока и сальдо до 2100 года
(Российская Федерация, субъекты РФ; по полу: мужчины, женщины, всего)
1. Входные данные и предпосылки
Исходными являются книги Росстата «Число прибывших по полу…» и «Число выбывших по полу…» за 2017–2023 годы в форме годовых счётных величин по субъектам РФ. В книгах возможны два распространённых формата: «узел» пола — отдельная колонка, либо пол зашит в заголовки годовых столбцов. Парсер автоматически распознаёт оба варианта, нормализует наименования территорий и извлекает наблюдения по мужчинам и по женщинам. Период 2017–2023 трактуется как фактический и в точности переносится в выпускные таблицы; изменения факта не допускаются.
Прогноз строится для каждой пары «территория × пол» независимо, затем формируется агрегат «всего» простым суммированием полов. Годы после 2023 относятся к прогнозному горизонту и заполняются непрерывно до 2100 года.
2. Концепция модели
Модель объединяет три ключевых компонента: циклическую аппроксимацию годовой динамики притока и оттока, мягкую гипотезу роста «мобильности» населения через минимальный рост оборота и обоснованные ограничения на траекторию сальдо в дальнем горизонте; все три компонента реализованы так, чтобы сохранять видимые в истории волнообразные формы и одновременно исключить нереалистичные всплески.
Во-первых, для каждого ряда y_t(приток I_tили отток O_t) на интервале наблюдений выполняется линейно-гармоническая регрессия
{\hat{y}}_t\mathrm{\;\hairsp}=\mathrm{\;\hairsp} a+b\mathrm{\thinsp}(t-t_0)+c\sin\funcapply\frac{2\pi(t-t_0)}{P}+d\cos\funcapply\frac{2\pi(t-t_0)}{P}.\bigm
Период Pподбирается перебором из множества {3,4,5,6,7,8}\ по минимуму среднеквадратичной ошибки на историческом участке, что даёт устойчивую среднесрочную волну без переобучения на коротких рядах. Если оценённый линейный коэффициент b<0, он обнуляется для прогноза, тем самым исключая систематическое убывание «мобильности» (см. пункт 3). Гармоническая амплитуда дополнительно ограничивается сверху долей среднего исторического уровня, чтобы исключить «разнос» от подгонки.
Во-вторых, на этапах формирования будущих траекторий притока и оттока вводится гипотеза слабого роста оборота T_t=I_t+O_tкак прокси «интенсивности миграционного обмена». Для каждого последующего года требуемый оборот не может быть ниже, чем оборот предыдущего года плюс минимальная прибавка, пропорциональная среднему историческому обороту (в базовой калибровке — не менее 0,5% среднего в год). Это вводит мягкую и монотонную «стропу» для T_t, уравновешивающую волны без линейного «заглаживания».
В-третьих, для сальдо N_t=I_t-O_tприменяется принцип «конуса правдоподобия» на всём прогнозном горизонте: допустимый коридор [LB,UB] задаётся как \pm50% от исторического диапазона [\min\funcapply N_t,\max\funcapply N_t]периода 2017–2023. Вместо поэлементного обрезания, которое может приводить к «прилипанию» к границе, вся будущая траектория «сырого» сальдо N_t^{raw}аффинно масштабируется к интервальному коридору относительно исторического центра (среднего N). Тем самым сохраняется волнообразная форма и фаза колебаний, но исключается выход за пределы [LB,UB]. В редких случаях, когда после масштабирования ряд оказывается излишне «плоским», добавляется минимальная синусоидальная «рифлёность» фиксированной фазы и малой амплитуды (десятая доля ширины коридора), строго остающаяся внутри [LB,UB]. Этот шаг предотвращает константные прогнозные сальдо, выявленные ранее на отдельных территориях при жёстком клипе.
После согласования целевого оборота T_tи сальдо N_tвосстанавливаются компонентные ряды I_t=(T_t+N_t)/2и O_t=(T_t-N_t)/2с принудительной неотрицательностью, затем округляются до целых значений.
3. Идентификация параметров и предохранители
Период гармоники Pвыбирается перебором с критерием MSE; линейный коэффициент bв прогнозе ограничивается снизу нулём, что отражает гипотезу отсутствия секулярного снижения миграционной мобильности. Гармонические амплитуды притока и оттока капируются долей от среднего уровня ряда; в базовой калибровке верхний предел амплитуды равен 35% среднего. Минимальный рост оборота установлен на уровне 0,5% среднего исторического оборота в год, но не ниже фиксированного положительного минимума, что стабилизирует траектории малых регионов. Коридор сальдо задаётся по правилу [LB,UB]=[1.5\cdot\min⁡Nthist, 1.5\cdot\max⁡Nthist]и используется для масштабирования всей будущей последовательности N_t^{raw}. Для детерминированной «рифлёности» применяется синусоидальный сигнал малой амплитуды с фазой, однозначно заданной строкой «территория×пол», что обеспечивает строгую воспроизводимость.
Все вычисления выполняются отдельно по полу; агрегат «всего» формируется суммированием полов по годам. На историческом сегменте 2017–2023 значения притока и оттока полностью совпадают с наблюдаемыми, статусы точек помечаются как «наблюдение», остальные годы — «прогноз». Генератор случайных чисел фиксируется заранее, однако в текущей версии модель прогнозирует детерминированные траектории, а не ансамбли, что исключает стохастический разброс между перезапусками.
4. Технологическая схема
Алгоритм включает устойчивый парсер исходных книг Росстата, нормализацию наименований территорий, согласование пересечения по парам «территория × пол», оценку циклических регрессий для притока и оттока на историческом окне, формирование «сырого» прогноза на весь горизонт, рескейлинг прогнозного сальдо внутри допустимого коридора и пошаговую сборку компонент через согласованный оборот. Для исключения артефактов применяются неотрицательность компонент и целое округление. Границы конуса и минимальный рост оборота вычисляются для каждой пары «территория × пол» из её собственных исторических данных, что обеспечивает территориально-специфичную калибровку.
5. Выходные наборы данных
Результаты выдаются в «длинном» и «широком» форматах с унифицированной структурой и полем статуса. Основной «длинный» набор содержит колонки «Территория», «Пол», «Год», «Прибыл», «Выбыл», «Сальдо», «Статус». Основной «широкий» файл — единая книга Excel с тремя листами: inflow (приток), outflow (отток) и saldo (сальдо); строки — годы от 2017 до 2100, колонки — парная многоуровневая структура [Территория, Пол], включая и агрегат «Всего». Все выпускные ряды непрерывны по годам и не содержат пропусков.
Имена файлов, формируемых кодом: «MIG_cyclic_tidy.csv» и «MIG_cyclic_tidy.xlsx» для длинного формата и «MIG_cyclic_wide.xlsx» для широкого формата с тремя листами. Структура согласована с ранее подготовленными прогнозами рождаемости, ожидаемой продолжительности жизни и численности населения, что позволяет использовать их в едином сценарном конвейере.
6. Воспроизводимость и настраиваемые параметры
Для воспроизводимости фиксируются: набор кандидатных периодов P\in{3,4,5,6,7,8}; доля максимальной амплитуды гармоники по отношению к среднему уровню ряда (по умолчанию 35%); минимальный годовой рост оборота в долях среднего исторического оборота (по умолчанию 0,5%); множитель ширины конуса для сальдо (по умолчанию \pm50%от исторического диапазона); детерминированная фаза минимальной гармоники для предотвращения вырождения сальдо в константу. Все параметры заданы на уровне, обеспечивающем баланс между реалистичностью и устойчивостью на коротких исторических окнах; при необходимости они могут быть переоценены для альтернативных сценариев.
7. Ограничения и интерпретация
Методика специально разработана для краткой исходной истории (семь годовых наблюдений), в которой оценка «статистической» периодичности неизбежно имеет ограниченную точность; поэтому гармоника намеренно ограничена по амплитуде, а долгосрочный рост оборота — минимален и служит лишь стабилизатором динамики, а не источником экспоненциального тренда. Конус сальдо защищает от нереалистичных сценариев при длинной экстраполяции и одновременно сохраняет волнообразную структуру. В интерпретации результатов следует учитывать, что внешние структурные шоки, институциональные изменения и территориально-специфические программы, не присутствующие в исходном окне 2017–2023 гг., в модель не зашиты и должны рассматриваться отдельно в сценарной работе.</pre>
      </details>
      <details>
        <summary>Численность населения</summary>
        <pre class="method-text">Методическое описание прогноза численности и состава населения субъектов РФ 
на период до 2100 года
1. Исходные данные и их роль в модели
В расчётах используются пять источников, все по субъектам РФ: годовые прогнозы ожидаемой продолжительности жизни при рождении (по полу) как драйвер смертности; годовые прогнозы суммарного коэффициента рождаемости как драйвер рождаемости; годовое миграционное сальдо по полу; базовые возрастно-половые распределения численности по субъектам, являющиеся стартовым состоянием; фиксированное соотношение полов при рождении, равное 105,6 мальчика на 100 девочек. ОПЖ e0 и СКР подаются в «tidy»-виде с явными полями «Территория», «Год», «Пол»/«TFR»; миграция — с полями «Территория», «Пол», «Год», «Сальдо». Возрастные базы населения подаются в книгах Excel, где первый столбец — возраст (включая категорию «100 и более»), второй — субъект, последующие столбцы — годы наблюдений (например, «2022», «2023», «2024», «2025»).
2. Предобработка и нормализация
Для возрастных книг используется строгий парсер формата «Возраст | Территория | Годы…». Возрастные метки нормализуются регулярными выражениями в целые возраста 0–99 и «100+»→100. Из заголовков столбцов извлекаются четырёхзначные годы; для каждого листа формируется длинная таблица «Территория–Пол–Год–Возраст–Число». Дубликаты по ключу агрегируются суммированием, исключаются пустые и явно некорректные строки. Для каждой пары «территория–пол» выбирается максимальный доступный наблюдаемый год базового распределения; это год старта передвижки.
Для ОПЖ и СКР автоматически определяются названия колонок с «территорией» и «годом»; для СКР дополнительно выбирается «главная» числовая колонка TFR по правдоподобному диапазону, доле числовых значений и ключевым словам в имени. Миграция приводится к двум полу-специфическим временным рядам сальдо.
Если для части лет отсутствуют значения e0 или TFR, используется ближайшее по времени доступное значение данной территории и пола; при полном отсутствии — безопасный фоллбэк по полу (например, e0=70 для мужчин/78 для женщин; TFR=1,5). Эти фоллбэки применяются только там, где исходные файлы действительно не содержат значений, и фиксируются в диагностическом логировании ноутбука.
3. Модуль смертности: таблицы жизни из e0
Для каждого пола задан гладкий «шаблон» возрастных смертностей m_x^{templ}(приближённая Gompertz–Makeham-подобная кривая с реалистичной младенческой и детской смертностью), из которого для каждого года и территории строится индивидуальная таблица жизни, строго согласованная с заданным e0. Согласование выполняется масштабированием m_x=s\cdot m_x^{templ}методом двоичного поиска по множителю sдо тех пор, пока ожидаемая продолжительность жизни e_0таблички не совпадёт с целевой в пределах допуска. На основе полученных m_xрассчитываются стандартные показатели q_x,l_x,L_x,T_xи межвозрастные вероятности дожития S_x=l_{x+1}/l_x(для открытой группы «100+» — экспоненциальное приближение S_{100}=\exp\funcapply(-m_{100})). Эти S_xдалее используются как коэффициенты выживания в переходе из года tв год t+1.
4. Модуль рождаемости: дисагрегация TFR в ASFR
Годовой TFR по территории развивается по прогнозу. Для распределения его по одно-летным возрастам 15–49 лет используется фиксированный гладкий весовой профиль возрастных коэффициентов рождаемости w_a(нормированный к сумме равной 1; центр массы около 27–29 лет и реалистичное затухание к краям). Возрастные коэффициенты задаются как {\rm ASFR}_a=TFR\cdot w_a. Число рождений в году tвычисляется как скалярное произведение женской экспозиции по возрастам на начало года и вектора ASFR. Половое соотношение при рождении фиксировано: доля мальчиков p_m=\frac{105,6}{105,6+100}, девочек p_f=1-p_m. Выживание новорождённых в первый год жизни учитывается через S_0пола, рассчитанный из таблицы жизни для текущего года и территории.
5. Модуль миграции: распределение годового сальдо по возрастам
В сценарии «с миграцией» используется годовое миграционное сальдо по полу из входного файла. Это сальдо разбрасывается по возрастам с помощью гладкого профиля Rogers–Castro (модальная молодая волна с небольшими долями в детско-подростковых и старших возрастах). Отрицательное сальдо автоматически даёт отрицательные прибавки; после применения миграции каждое возрастно-половое значение отсекательно ограничивается нулём снизу. В сценарии «без миграции» весь блок сальдо обнуляется для всех территорий и лет, что позволяет получить чисто естественный демографический сценарий.
6. Передвижка возрастов (когортно-компонентная проекция)
Проекция для каждой территории выполняется итеративно от базового года t_0до 2100 года. На каждом шаге для мужчин и женщин выполняются операции в фиксированном порядке: выживание и старение когорт по S_x; рождение мальчиков и девочек по {\rm ASFR}_aи S_0; добавление миграции по возрастным профилям; техническое обрезание отрицательных значений до нуля. Для открытой группы «100+» смертность и миграция накапливаются аддитивно, а выживание реализовано умножением на S_{100}. Наблюдаемые базовые годы, присутствующие в исходных возрастных книгах, включаются в итог без каких-либо модификаций; после базового года все значения являются прогнозными и помечаются соответствующим статусом. Итог по полу «Всего» формируется суммированием мужского и женского массивов на каждом шаге.
7. Контроль качества и устойчивости
До старта расчёта проверяется полнота базовых возрастных матриц для каждой пары «территория–пол–год»: количество уникальных возрастов и суммарная численность должны быть положительными; подозрительные случаи выводятся в диагностике. Внутри шага моделирования реализованы гарантии неотрицательности для всех ячеек, согласование младенческой выживаемости с таблицей жизни, а также детерминированность результата: расчёт не использует случайности, все операции при фиксированных входах повторяемы. Для предотвращения переполнения Excel-листов полный возрастной «tidy» массив пишется в CSV; широкие и сводные таблицы, имеющие разумный размер, выгружаются в XLSX.
8. Выходные файлы и их содержимое
Алгоритм формирует два полных комплекта файлов — для сценария «с миграцией» (суффикс withMIG) и «без миграции» (суффикс noMIG). Полный возрастной массив по всем территориям, полам, годам и одно-летным возрастам сохраняется в файлах POP_forecast_age_tidy_withMIG.csv и POP_forecast_age_tidy_noMIG.csv. В каждом CSV содержатся поля «Территория», «Пол», «Год», «Возраст», «ВозрастСтрока» (включая «100+»), «Численность» (целое), «Статус» («наблюдение» или «прогноз»).
Дополнительно создаются широкие XLSX-таблицы по каждому полу и по итогу «Всего»: POP_wide_male_{scenario}.xlsx, POP_wide_female_{scenario}.xlsx, POP_wide_total_{scenario}.xlsx. В каждой книге три листа: «by_age» — матрица [\mathrm{Территория×Год]на возрастных колонках 0, 1, …, 99, «100+»; «by_territory» — матрица [\mathrm{Год×Территория]годовых итогов по полу; «status» — аналогичная матрица статусов «наблюдение/прогноз».
Сформированы также компактные «tidy»-итоги по полу и итогу «Всего»: POP_total_tidy_withMIG.(csv|xlsx) и POP_total_tidy_noMIG.(csv|xlsx). В них на каждый год и территорию приводится агрегированная численность по полу и общий итог; формат предназначен для быстрого анализа динамики и агрегирования по уровням.
9. Интерпретация и ограничения
Представленный контур — строгая когортно-компонентная передвижка, где смертность привязана к заданной траектории e0 через таблицу жизни, рождаемость — к траектории TFR через фиксированный возрастной профиль, миграция — к годовому сальдо через гладкий возрастной профиль. Это обеспечивает согласованность с входными прогнозами e0 и TFR, физическую реализуемость возрастных эволюций и прозрачность вклада каждого компонента. Ограничения связаны с экзогенно заданной формой профилей: возрастной профиль рождаемости не варьируется во времени и по территориям; миграционный профиль одинаков по годам и зависит только от пола; смертность калибруется по e0 с использованием шаблонной формы m_x, а не по полноценным возрастным рядам q_x. Вопросы темпа рождаемости, сдвигов когорто-возрастных паттернов фертильности, а также разложений миграции на потоки прибытия/выбытия находятся за пределами текущей реализации и могут быть добавлены как расширения при наличии соответствующих данных.
10. Возможные расширения
По мере необходимости возможна замена фиксированных профилей на территориально- и временнó-специфические: прогноз ASFR по возрастам вместо TFR×weights; прогноз возрастно-специфической смертности по полу (например, через улучшения m_xили q_x); разложение миграции на приток и отток с отдельными возрастными профилями и согласованием с сальдо; учёт потенциальных шоков через сценарные множители к S_x, ASFR и возрастным профилям миграции. Эти расширения совместимы с текущей структурой кода и файлов и могут быть реализованы без изменения формата выдачи.</pre>
      </details>
    </div>
  </div>

  <div id="logBox" class="card small"></div>
</main>
<footer>
  Ситковский Арсений Михайлович, 2025
</footer>

<script>
// ------------------- Конфигурация файлов -------------------
const files = {
  le:  'LE_Russia_subjects_forecast_2100_long.csv',
  tfr: 'TFR_Russia_subjects_ML_GP_UCM_tidy.csv',
  mig: 'MIG_cyclic_tidy.csv',
  pop_xlsx: {
    withMIG: { male: 'POP_wide_male_withMIG.xlsx', female: 'POP_wide_female_withMIG.xlsx' },
    noMIG:   { male: 'POP_wide_male_noMIG.xlsx',  female: 'POP_wide_female_noMIG.xlsx'  }
  }
};

const state = {
  le: [], tfr: [], mig: [],
  pop_with: [], pop_nom: [],
  terrs: [],
  years: {min:2017, max:2100}
};

function exportToXLSX(filename, rows, sheetName='Данные'){
  if(!rows || !rows.length){
    alert('Нет данных для выгрузки. Проверьте выбранные фильтры.');
    return;
  }
  const ws = XLSX.utils.json_to_sheet(rows);
  const wb = {SheetNames:[sheetName], Sheets:{}};
  wb.Sheets[sheetName] = ws;
  XLSX.writeFile(wb, filename);
}

// ------------------- Утилиты -------------------
function trim(x){ return (x==null? '' : String(x)).trim(); }
function cleanTerritory(x){
  // убираем случайные номера/точки перед названием
  return trim(x).replace(/^[0-9.,\-]+\)?\s*/,'');
}
function toInt(x){
  const v = parseInt(String(x).replace(/\s+/g,''),10);
  return Number.isFinite(v)? v : null;
}
function toNum(x){
  const v = Number(String(x).replace(/\s+/g,'').replace(',', '.'));
  return Number.isFinite(v)? v : null;
}
function normSex(s){
  s = trim(s).toLowerCase();
  if(!s) return '';
  if(s.startsWith('муж')) return 'Мужчины';
  if(s.startsWith('жен')) return 'Женщины';
  if(s.includes('всего') || s.includes('итог') || s.includes('total')) return 'Всего';
  if(s.includes('male')) return 'Мужчины';
  if(s.includes('fem') || s.includes('women')) return 'Женщины';
  return s;
}

// ключевой фикс: карта алиасов -> имена колонок
function normMapFromHeaders(row){
  const m = {};
  Object.keys(row || {}).forEach(k=>{
    const kk = k.toLowerCase().trim();
    if(!m[kk]) m[kk] = k;
  });
  return m;
}

function guessCol(map, aliases){
  for(const a of aliases){
    const key = a.toLowerCase();
    if(map[key]) return map[key];
  }
  return null;
}

function parseCSV(url){
  return new Promise((resolve, reject)=>{
    Papa.parse(url, {
      header:true,
      download:true,
      dynamicTyping:false,
      skipEmptyLines:true,
      complete: r => resolve(r.data),
      error: err => reject(err)
    });
  });
}

async function fetchArrayBuffer(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error(`HTTP ${res.status} при загрузке ${url}`);
  return await res.arrayBuffer();
}

// ------------------- Нормализация LE -------------------
function normalizeLE(rows){
  if(!rows || !rows.length) return [];
  const headerMap = normMapFromHeaders(rows[0]);
  const colT = guessCol(headerMap, ['территория','territory','регион','субъект','region','subject']);
  const colY = guessCol(headerMap, ['год','year']);
  const colS = guessCol(headerMap, ['пол','sex','gender']);
  const colLE1 = guessCol(headerMap, ['le','ожидаемая продолжительность жизни','опж','life expectancy']);
  const colSt = guessCol(headerMap, ['статус','status']);

  // если не нашли явную колонку с LE, попробуем взять любой числовой столбец
  let colLE = colLE1;
  if(!colLE){
    const headers = Object.keys(rows[0]);
    outer: for(const h of headers){
      if(h===colT || h===colY || h===colS || h===colSt) continue;
      let cnt=0, good=0;
      for(let i=0;i<rows.length && i<100;i++){
        const v = toNum(rows[i][h]);
        if(v==null) continue;
        cnt++;
        if(v>20 && v<100) good++;
      }
      if(cnt>10 && good/cnt>0.8){ colLE=h; break outer; }
    }
  }
  if(!colT || !colY || !colS || !colLE){
    console.warn('LE: не удалось однозначно определить структуру колонок', {colT,colY,colS,colLE});
    return [];
  }

  const out=[];
  for(const r of rows){
    const t = cleanTerritory(r[colT]); if(!t) continue;
    const y = toInt(r[colY]); if(!y) continue;
    const sx = normSex(r[colS]); if(sx!=='Мужчины' && sx!=='Женщины') continue;
    const v  = toNum(r[colLE]); if(v==null) continue;
    const st = colSt? trim(r[colSt]) : (y<=2023? 'наблюдение':'прогноз');
    out.push({Территория:t, Пол:sx, Год:y, LE:v, Статус:st});
  }
  out.sort((a,b)=> a.Территория.localeCompare(b.Территория) || a.Пол.localeCompare(b.Пол) || (a.Год-b.Год));
  return out;
}

// ------------------- Нормализация TFR -------------------
function normalizeTFR(rows){
  if(!rows || !rows.length) return [];
  const headerMap = normMapFromHeaders(rows[0]);
  const colT = guessCol(headerMap, ['территория','territory','регион','субъект','region','subject']);
  const colY = guessCol(headerMap, ['год','year']);
  const colSt= guessCol(headerMap, ['статус','status']);
  let   colV = guessCol(headerMap, ['tfr','суммарный коэффициент рождаемости','скр','value','mean','median']);

  if(!colV){
    const headers = Object.keys(rows[0]);
    outer: for(const h of headers){
      if(h===colT || h===colY || h===colSt) continue;
      let cnt=0, good=0;
      for(let i=0;i<rows.length && i<100;i++){
        const v = toNum(rows[i][h]);
        if(v==null) continue;
        cnt++;
        if(v>0.5 && v<5.0) good++;
      }
      if(cnt>10 && good/cnt>0.7){ colV=h; break outer; }
    }
  }

  if(!colT || !colY || !colV){
    console.warn('TFR: не удалось однозначно определить структуру колонок', {colT,colY,colV});
    return [];
  }

  const out=[];
  for(const r of rows){
    const t = cleanTerritory(r[colT]); if(!t) continue;
    const y = toInt(r[colY]); if(!y) continue;
    const v = toNum(r[colV]); if(v==null) continue;
    const st = colSt? trim(r[colSt]) : (y<=2023? 'наблюдение':'прогноз');
    out.push({Территория:t, Год:y, TFR:v, Статус:st});
  }
  out.sort((a,b)=> a.Территория.localeCompare(b.Территория) || (a.Год-b.Год));
  return out;
}

// ------------------- Нормализация миграции -------------------
function normalizeMIG(rows){
  if(!rows || !rows.length) return [];
  const headerMap = normMapFromHeaders(rows[0]);
  const colT = guessCol(headerMap, ['территория','territory','регион','субъект','region','subject']);
  const colY = guessCol(headerMap, ['год','year']);
  const colS = guessCol(headerMap, ['пол','sex','gender']);
  const colI = guessCol(headerMap, ['прибыв','inflow','прибыл']);
  const colO = guessCol(headerMap, ['выбыл','outflow']);
  const colN = guessCol(headerMap, ['сальдо','saldo','balance']);
  const colSt= guessCol(headerMap, ['статус','status']);

  if(!colT || !colY || !colS){
    console.warn('MIG: не удалось однозначно определить ключевые колонки', {colT,colY,colS});
    return [];
  }

  const out=[];
  for(const r of rows){
    const t = cleanTerritory(r[colT]); if(!t) continue;
    const y = toInt(r[colY]); if(!y) continue;
    const s = normSex(r[colS]); if(!s) continue;
    const infl = colI? toInt(r[colI]) : null;
    const outf = colO? toInt(r[colO]) : null;
    let   sald = colN? toInt(r[colN]) : null;
    if(sald==null && infl!=null && outf!=null) sald = infl-outf;
    const st   = colSt? trim(r[colSt]) : (y<=2023? 'наблюдение':'прогноз');
    out.push({Территория:t, Пол:s, Год:y, Прибыл:infl, Выбыл:outf, Сальдо:sald, Статус:st});
  }
  out.sort((a,b)=> a.Территория.localeCompare(b.Территория) || a.Пол.localeCompare(b.Пол) || (a.Год-b.Год));
  return out;
}

// ------------------- Парсинг XLSX: возраст × год -------------------
function parseWideSheetToTidy(rows, sexLabel, statusRule){
  // Формат файлов: первая строка — заголовки "Территория | Год | 0 | 1 | ... 100+",
  // далее по нескольку строк на один регион (территория указывается только в первой строке блока).
  if(!rows || !rows.length) return [];

  let hdrIdx = -1;
  let idxTerr = null, idxYear = null;

  for(let i=0;i<Math.min(rows.length,20);i++){
    const r = rows[i] || [];
    r.forEach((cell, j)=>{
      const s = trim(cell).toLowerCase();
      if(s==='территория' || s==='territory') idxTerr = j;
      if(s==='год' || s==='year') idxYear = j;
    });
    if(idxTerr!=null && idxYear!=null){ hdrIdx = i; break; }
  }
  if(hdrIdx<0 || idxTerr==null || idxYear==null) return [];

  const hdr = rows[hdrIdx] || [];
  const ageCols = [];
  for(let j=0;j<hdr.length;j++){
    if(j===idxTerr || j===idxYear) continue;
    const s = trim(hdr[j]);
    if(/^\d+$/.test(s) || s==='100+' || s.includes('и более')) ageCols.push(j);
  }
  if(!ageCols.length) return [];

  const tidy=[];
  let lastTerr='';

  for(let i=hdrIdx+1;i<rows.length;i++){
    const r = rows[i] || [];
    const terrRaw = r[idxTerr];
    const terr = terrRaw ? cleanTerritory(terrRaw) : lastTerr;
    if(!terr) continue;
    lastTerr = terr;

    const year = toInt(r[idxYear]);
    if(year==null) continue;

    for(const j of ageCols){
      const ageTxt = trim(hdr[j]);
      const age = ageTxt==='100+' ? 100 : toInt(ageTxt);
      if(age==null) continue;
      const v = toNum(r[j]);
      if(v==null) continue;
      tidy.push({
        Территория: terr,
        Пол: sexLabel,
        Год: year,
        Возраст: age,
        Численность: v,
        Статус: statusRule(year)
      });
    }
  }

  tidy.sort((a,b)=>
    a.Территория.localeCompare(b.Территория) ||
    a.Пол.localeCompare(b.Пол) ||
    (a.Год-b.Год) ||
    (a.Возраст-b.Возраст)
  );
  return tidy;
}

async function loadPopulationFromXLSX(cfg){
  const statusRule = (y)=> (y<=2025? 'наблюдение':'прогноз');
  const tidy = [];

  if(cfg.female){
    const bufF = await fetchArrayBuffer(cfg.female);
    const wbF = XLSX.read(bufF, {type:'array'});
    wbF.SheetNames.forEach(sh=>{
      const rows = XLSX.utils.sheet_to_json(wbF.Sheets[sh], {header:1, raw:true});
      const parsed = parseWideSheetToTidy(rows, 'Женщины', statusRule);
      for(const rec of parsed) tidy.push(rec);
    });
  }
  if(cfg.male){
    const bufM = await fetchArrayBuffer(cfg.male);
    const wbM = XLSX.read(bufM, {type:'array'});
    wbM.SheetNames.forEach(sh=>{
      const rows = XLSX.utils.sheet_to_json(wbM.Sheets[sh], {header:1, raw:true});
      const parsed = parseWideSheetToTidy(rows, 'Мужчины', statusRule);
      for(const rec of parsed) tidy.push(rec);
    });
  }
  tidy.sort((a,b)=>
    a.Территория.localeCompare(b.Территория) ||
    a.Пол.localeCompare(b.Пол) ||
    (a.Год-b.Год) ||
    (a.Возраст-b.Возраст)
  );
  return tidy;
}

// ------------------- Загрузка всех источников -------------------
function uniqueTerrs(arr){
  const s = new Set();
  arr.forEach(r=>{ if(r && r.Территория) s.add(r.Территория); });
  return Array.from(s).sort((a,b)=> a.localeCompare(b));
}

function countTerrs(arr){
  return uniqueTerrs(arr).length;
}

function showSummary(){
  const log = document.getElementById('logBox');
  const lines = [];

  const terrLE  = countTerrs(state.le);
  const terrTFR = countTerrs(state.tfr);
  const terrMIG = countTerrs(state.mig);
  const terrPW  = countTerrs(state.pop_with);
  const terrPN  = countTerrs(state.pop_nom);

  lines.push('Сводка загрузки данных:');
  lines.push(`• LE: ${state.le.length.toLocaleString('ru-RU')} записей, территорий: ${terrLE}`);
  lines.push(`• TFR: ${state.tfr.length.toLocaleString('ru-RU')} записей, территорий: ${terrTFR}`);
  lines.push(`• Миграция: ${state.mig.length.toLocaleString('ru-RU')} записей, территорий: ${terrMIG}`);
  lines.push(`• Возрастная численность (с миграцией): ${state.pop_with.length.toLocaleString('ru-RU')} записей, территорий: ${terrPW}`);
  lines.push(`• Возрастная численность (без миграции): ${state.pop_nom.length.toLocaleString('ru-RU')} записей, территорий: ${terrPN}`);
  lines.push('');

  const warns = [];
  if(!state.le.length)  warns.push('! LE: не найдено ни одной строки. Проверьте имена колонок и кодировку файла LE_Russia_subjects_forecast_2100_long.csv');
  if(!state.tfr.length) warns.push('! TFR: не найдено ни одной строки. Проверьте имена колонок и кодировку файла TFR_Russia_subjects_ML_GP_UCM_tidy.csv');
  if(!state.pop_with.length && !state.pop_nom.length)
    warns.push('! Возрастная численность: нет данных (с миграцией и/или без миграции). Проверьте четыре файла POP_wide_*.xlsx');
  if(!warns.length) warns.push('Ошибок загрузки не обнаружено.');
  lines.push('Предупреждения:');
  warns.forEach(w=>lines.push(w));

  log.textContent = lines.join('\n');
}

async function loadAll(){
  const log = document.getElementById('logBox');
  log.textContent = 'Загрузка данных…';
  try{
    const [leR, tfrR, migR] = await Promise.all([
      parseCSV(files.le),
      parseCSV(files.tfr),
      parseCSV(files.mig)
    ]);
    state.le  = normalizeLE(leR);
    state.tfr = normalizeTFR(tfrR);
    state.mig = normalizeMIG(migR);

    const [popWith, popNom] = await Promise.all([
      loadPopulationFromXLSX(files.pop_xlsx.withMIG),
      loadPopulationFromXLSX(files.pop_xlsx.noMIG)
    ]);
    state.pop_with = popWith;
    state.pop_nom  = popNom;

    const terrs = new Set();
    [...state.le, ...state.tfr, ...state.mig, ...state.pop_with, ...state.pop_nom]
      .forEach(r=>{ if(r && r.Территория) terrs.add(r.Территория); });
    state.terrs = Array.from(terrs).sort((a,b)=> a.localeCompare(b));

    const yearsSet = new Set();
    [...state.pop_with, ...state.pop_nom].forEach(r=>{ if(r && r.Год!=null) yearsSet.add(r.Год); });
    const yall = Array.from(yearsSet);
    if(yall.length){
      state.years.min = Math.min(...yall, 2017);
      state.years.max = Math.max(...yall, 2100);
    }

    initUI();
    showSummary();
  }catch(e){
    console.error(e);
    log.innerHTML = '<span class="err">Ошибка загрузки: '+(e.message || e)+'</span>';
  }
}

// ------------------- Отрисовка UI и графиков -------------------
function initUI(){
  const selT = document.getElementById('territorySel');
  selT.innerHTML = state.terrs.map(t=>`<option value="${t}">${t}</option>`).join('');
  if(state.terrs.length) selT.value = state.terrs[0];

  const yRange = document.getElementById('yearRange');
  const yInput = document.getElementById('yearInput');
  yRange.min = state.years.min;
  yRange.max = state.years.max;
  yRange.value = Math.min(2025, state.years.max);
  yInput.min = state.years.min;
  yInput.max = state.years.max;
  yInput.value = yRange.value;

  selT.addEventListener('change', renderAll);
  document.getElementById('scenarioSel').addEventListener('change', renderPyramid);
  yRange.addEventListener('input', e=>{
    yInput.value = e.target.value;
    renderPyramid();
  });
  yInput.addEventListener('input', e=>{
    const v = clampYear(parseInt(e.target.value,10));
    if(v!=null){
      yRange.value = v;
      yInput.value = v;
      renderPyramid();
    }
  });
  document.getElementById('chkMigMale').addEventListener('change', renderMigration);
  document.getElementById('chkMigFem').addEventListener('change', renderMigration);
  document.getElementById('chkMigTot').addEventListener('change', renderMigration);
  document.getElementById('btnTFRPNG').onclick = ()=> Plotly.downloadImage('chartTFR', {format:'png', filename:'tfr'});
  document.getElementById('btnLEPNG').onclick  = ()=> Plotly.downloadImage('chartLE',  {format:'png', filename:'life_expectancy'});
  document.getElementById('btnMigPNG').onclick = ()=> Plotly.downloadImage('chartMIG', {format:'png', filename:'migration'});
  document.getElementById('btnPopPNG').onclick = ()=> Plotly.downloadImage('chartPop', {format:'png', filename:'population_total'});
  document.getElementById('btnPyrPNG').onclick = ()=> Plotly.downloadImage('chartPYR', {format:'png', filename:'population_pyramid'});

  document.getElementById('btnTFRXLSX').onclick = exportTFRXLSX;
  document.getElementById('btnLEXLSX').onclick  = exportLEXLSX;
  document.getElementById('btnMigXLSX').onclick = exportMigXLSX;
  document.getElementById('btnPopXLSX').onclick = exportPopXLSX;
  document.getElementById('btnPyrXLSX').onclick = exportPyrXLSX;

  renderAll();
}

function renderAll(){
  renderTFR();
  renderLE();
  renderPopTotal();
  renderMigration();
  renderPyramid();
}

function exportTFRXLSX(){
  const terr = document.getElementById('territorySel').value;
  const rows = state.tfr
    .filter(r=> r.Территория===terr)
    .map(r=>({
      Территория:r.Территория,
      Год:r.Год,
      'СКР, детей на женщину': r.TFR,
      Статус:r.Статус
    }));
  exportToXLSX(`tfr_${terr}.xlsx`, rows, 'СКР');
}

function exportLEXLSX(){
  const terr = document.getElementById('territorySel').value;
  const rows = state.le
    .filter(r=> r.Территория===terr)
    .map(r=>({
      Территория:r.Территория,
      Пол:r.Пол,
      Год:r.Год,
      'ОПЖ при рождении, лет': r.LE,
      Статус:r.Статус
    }));
  exportToXLSX(`le_${terr}.xlsx`, rows, 'ОПЖ');
}

function exportPopXLSX(){
  const terr = document.getElementById('territorySel').value;
  const scenarios = [
    {key:'withMIG', title:'С учётом миграции'},
    {key:'noMIG', title:'Без миграции'}
  ];
  const rows = [];
  for(const scen of scenarios){
    const src = (scen.key==='withMIG'? state.pop_with : state.pop_nom).filter(r=> r.Территория===terr);
    const grouped = new Map();
    src.forEach(r=>{
      const year = r.Год;
      const rec = grouped.get(year) || {численность:0, статус:r.Статус};
      rec.численность += r.Численность || 0;
      rec.статус = r.Статус || rec.статус;
      grouped.set(year, rec);
    });
    Array.from(grouped.keys()).sort((a,b)=>a-b).forEach(y=>{
      const info = grouped.get(y);
      rows.push({
        Территория:terr,
        Сценарий:scen.title,
        Год:y,
        'Численность, человек': Math.round(info.численность),
        Статус:info.статус
      });
    });
  }
  exportToXLSX(`population_${terr}.xlsx`, rows, 'Численность');
}

function exportMigXLSX(){
  const terr = document.getElementById('territorySel').value;
  const showM = document.getElementById('chkMigMale').checked;
  const showF = document.getElementById('chkMigFem').checked;
  const showT = document.getElementById('chkMigTot').checked;
  const allowed = new Set();
  if(showM) allowed.add('Мужчины');
  if(showF) allowed.add('Женщины');
  if(showT) allowed.add('Всего');
  const rows = state.mig
    .filter(r=> r.Территория===terr && allowed.has(r.Пол))
    .map(r=>({
      Территория:r.Территория,
      Пол:r.Пол,
      Год:r.Год,
      'Прибыло, человек': r.Прибыл,
      'Выбыло, человек': r.Выбыл,
      'Сальдо, человек': r.Сальдо,
      Статус:r.Статус
    }));
  exportToXLSX(`migration_${terr}.xlsx`, rows, 'Миграция');
}

function exportPyrXLSX(){
  const terr = document.getElementById('territorySel').value;
  const scen = document.getElementById('scenarioSel').value;
  const year = getSelectedYear();
  const title = scen==='withMIG'? 'С учётом миграции' : 'Без миграции';
  const src  = (scen==='withMIG'? state.pop_with : state.pop_nom)
                 .filter(r=> r.Территория===terr && r.Год===year);
  const rows = src.map(r=>({
    Территория:r.Территория,
    Сценарий:title,
    Год:r.Год,
    Возраст:r.Возраст,
    Пол:r.Пол,
    'Численность, человек': r.Численность,
    Статус:r.Статус
  }));
  exportToXLSX(`pyramid_${terr}_${year}.xlsx`, rows, 'Пирамида');
}

// ----- TFR -----
function renderTFR(){
  const terr = document.getElementById('territorySel').value;
  const rows = state.tfr.filter(r=> r.Территория===terr);
  const fact = rows.filter(r=> (r.Статус||'').toLowerCase().startsWith('наб'));
  const fcst = rows.filter(r=> (r.Статус||'').toLowerCase().startsWith('прог'));
  const tr=[];
  if(fact.length){
    tr.push({
      x: fact.map(d=>d.Год),
      y: fact.map(d=>d.TFR),
      mode:'lines',
      line:{color:'#1f77b4', width:2},
      name:'СКР (факт)'
    });
  }
  if(fcst.length){
    tr.push({
      x: fcst.map(d=>d.Год),
      y: fcst.map(d=>d.TFR),
      mode:'lines',
      line:{color:'#1f77b4', width:2, dash:'dash'},
      name:'СКР (прогноз)'
    });
  }
  const layout = {
    margin:{l:60,r:20,t:20,b:40},
    yaxis:{title:'Детей на одну женщину', zeroline:false},
    xaxis:{title:'Год'},
    legend:{orientation:'h'}
  };
  Plotly.newPlot('chartTFR', tr, layout, {responsive:true, displayModeBar:false});
}

// ----- ОПЖ -----
function renderLE(){
  const terr = document.getElementById('territorySel').value;
  const rows = state.le.filter(r=> r.Территория===terr);
  const males = rows.filter(r=> r.Пол==='Мужчины');
  const fems  = rows.filter(r=> r.Пол==='Женщины');

  const mf = males.filter(r=> (r.Статус||'').toLowerCase().startsWith('наб'));
  const mc = males.filter(r=> (r.Статус||'').toLowerCase().startsWith('прог'));
  const ff = fems .filter(r=> (r.Статус||'').toLowerCase().startsWith('наб'));
  const fc = fems .filter(r=> (r.Статус||'').toLowerCase().startsWith('прог'));

  const tr=[];
  if(mf.length) tr.push({x:mf.map(d=>d.Год), y:mf.map(d=>d.LE), mode:'lines', line:{color:'#1f77b4'}, name:'Мужчины (факт)'});
  if(mc.length) tr.push({x:mc.map(d=>d.Год), y:mc.map(d=>d.LE), mode:'lines', line:{color:'#1f77b4', dash:'dash'}, name:'Мужчины (прогноз)'});
  if(ff.length) tr.push({x:ff.map(d=>d.Год), y:ff.map(d=>d.LE), mode:'lines', line:{color:'#d62728'}, name:'Женщины (факт)'});
  if(fc.length) tr.push({x:fc.map(d=>d.Год), y:fc.map(d=>d.LE), mode:'lines', line:{color:'#d62728', dash:'dash'}, name:'Женщины (прогноз)'});

  const layout = {
    margin:{l:60,r:20,t:20,b:40},
    yaxis:{title:'Лет', zeroline:false},
    xaxis:{title:'Год'},
    legend:{orientation:'h'}
  };
  Plotly.newPlot('chartLE', tr, layout, {responsive:true, displayModeBar:false});
}

// ----- Численность населения (итого) -----
function renderPopTotal(){
  const terr = document.getElementById('territorySel').value;
  const scenarios = [
    {key:'withMIG', title:'С учётом миграции', color:'#2ca02c'},
    {key:'noMIG', title:'Без миграции', color:'#9467bd'}
  ];

  const tr=[];
  for(const scen of scenarios){
    const src = (scen.key==='withMIG'? state.pop_with : state.pop_nom).filter(r=> r.Территория===terr);
    if(!src.length) continue;
    const grouped = new Map();
    src.forEach(r=> grouped.set(r.Год, (grouped.get(r.Год)||0) + (r.Численность||0)));

    const factYears = new Set(src.filter(r=> (r.Статус||'').toLowerCase().startsWith('наб')).map(r=> r.Год));
    const years = Array.from(grouped.keys()).sort((a,b)=>a-b);
    const xFact = years.filter(y=> factYears.has(y));
    const yFact = xFact.map(y=> grouped.get(y));
    const xFcst = years.filter(y=> !factYears.has(y));
    const yFcst = xFcst.map(y=> grouped.get(y));

    if(xFact.length) tr.push({x:xFact, y:yFact, mode:'lines', line:{color:scen.color, width:3}, name:`${scen.title} (факт)`});
    if(xFcst.length) tr.push({x:xFcst, y:yFcst, mode:'lines', line:{color:scen.color, dash:'dash', width:3}, name:`${scen.title} (прогноз)`});
  }

  if(!tr.length){
    Plotly.purge('chartPop');
    return;
  }

  const layout = {
    margin:{l:70,r:20,t:30,b:40},
    yaxis:{title:'Человек', zeroline:false, separatethousands:true},
    xaxis:{title:'Год'},
    legend:{orientation:'h'}
  };
  Plotly.newPlot('chartPop', tr, layout, {responsive:true, displayModeBar:false});
}

// ----- Миграция -----
function renderMigration(){
  const terr = document.getElementById('territorySel').value;
  const showM = document.getElementById('chkMigMale').checked;
  const showF = document.getElementById('chkMigFem').checked;
  const showT = document.getElementById('chkMigTot').checked;

  const rows = state.mig.filter(r=> r.Территория===terr);
  if(!rows.length){
    Plotly.purge('chartMIG');
    return;
  }

  const sexes = [];
  if(showM) sexes.push('Мужчины');
  if(showF) sexes.push('Женщины');
  if(showT) sexes.push('Всего');

  const colors = { 'Мужчины':'#1f77b4', 'Женщины':'#d62728', 'Всего':'#7f7f7f' };
  const traces = [];

  for(const sex of sexes){
    const rs = rows.filter(r=> r.Пол===sex);
    if(!rs.length) continue;
    const fact = rs.filter(r=> (r.Статус||'').toLowerCase().startsWith('наб'));
    const fcst = rs.filter(r=> (r.Статус||'').toLowerCase().startsWith('прог'));

    if(fact.length){
      traces.push({
        x: fact.map(d=>d.Год),
        y: fact.map(d=> d.Сальдо || 0),
        type:'bar',
        marker:{color:colors[sex], opacity:0.5},
        name:`Сальдо ${sex} (факт)`
      });
    }
    if(fcst.length){
      traces.push({
        x: fcst.map(d=>d.Год),
        y: fcst.map(d=> d.Сальдо || 0),
        type:'bar',
        marker:{color:colors[sex], opacity:0.25},
        name:`Сальдо ${sex} (прогноз)`
      });
    }
  }

  function pushLine(sex, kind){
    const rs = rows.filter(r=> r.Пол===sex);
    if(!rs.length) return;
    const fact = rs.filter(r=> (r.Статус||'').toLowerCase().startsWith('наб'));
    const fcst = rs.filter(r=> (r.Статус||'').toLowerCase().startsWith('прог'));
    const col = colors[sex];
    const label = kind==='I' ? 'Прибыл' : 'Выбыл';

    if(fact.length){
      traces.push({
        x: fact.map(d=>d.Год),
        y: fact.map(d=> kind==='I' ? (d.Прибыл||0) : (d.Выбыл||0)),
        mode:'lines',
        line:{color:col, width:2},
        name:`${label} ${sex} (факт)`
      });
    }
    if(fcst.length){
      traces.push({
        x: fcst.map(d=>d.Год),
        y: fcst.map(d=> kind==='I' ? (d.Прибыл||0) : (d.Выбыл||0)),
        mode:'lines',
        line:{color:col, width:2, dash:'dash'},
        name:`${label} ${sex} (прогноз)`
      });
    }
  }

  for(const sex of sexes){
    pushLine(sex,'I');
    pushLine(sex,'O');
  }

  const layout = {
    barmode:'overlay',
    margin:{l:70,r:20,t:20,b:40},
    yaxis:{title:'Человек', separatethousands:true},
    xaxis:{title:'Год'},
    legend:{orientation:'h'}
  };
  Plotly.newPlot('chartMIG', traces, layout, {responsive:true, displayModeBar:false});
}

// ----- Половозрастная пирамида -----
function renderPyramid(){
  const terr = document.getElementById('territorySel').value;
  const scen = document.getElementById('scenarioSel').value;
  const year = getSelectedYear();
  const src  = (scen==='withMIG'? state.pop_with : state.pop_nom)
                 .filter(r=> r.Территория===terr && r.Год===year);

  if(!src.length){
    Plotly.purge('chartPYR');
    return;
  }

  const male = [];
  const female = [];
  const ages = [];

  for(let a=0;a<=100;a++){
    const m = src.find(r=> r.Пол==='Мужчины' && r.Возраст===a);
    const f = src.find(r=> r.Пол==='Женщины' && r.Возраст===a);
    male.push( m ? -Math.round(m.Численность || 0) : 0 );
    female.push( f ? Math.round(f.Численность || 0) : 0 );
    ages.push(a===100 ? '100+' : String(a));
  }

  const maxVal = Math.max(...male.map(v=> Math.abs(v)), ...female);
  const tickStep = niceStep(maxVal || 1);
  const ticks = [];
  const stepsCount = Math.max(1, Math.ceil(maxVal / tickStep));
  for(let i=-stepsCount; i<=stepsCount; i++) ticks.push(i * tickStep);

  const traces = [
    {
      type:'bar',
      x: male,
      y: ages,
      orientation:'h',
      name:'Мужчины',
      marker:{color:'#1f77b4'},
      hovertemplate:'%{y} лет: %{text} чел.<extra></extra>',
      text: male.map(v=> Math.abs(v).toLocaleString('ru-RU'))
    },
    {
      type:'bar',
      x: female,
      y: ages,
      orientation:'h',
      name:'Женщины',
      marker:{color:'#d62728'},
      hovertemplate:'%{y} лет: %{text} чел.<extra></extra>',
      text: female.map(v=> v.toLocaleString('ru-RU'))
    }
  ];

  const layout = {
    barmode:'relative',
    margin:{l:70,r:20,t:10,b:40},
    xaxis:{
      title:'Человек',
      tickvals:ticks,
      ticktext:ticks.map(v=> Math.abs(v).toLocaleString('ru-RU')),
      zeroline:true,
      zerolinewidth:1
    },
    yaxis:{title:'Возраст, лет', categoryorder:'array', categoryarray:[...ages].reverse()},
    legend:{orientation:'h'}
  };

  Plotly.newPlot('chartPYR', traces, layout, {responsive:true, displayModeBar:false});
}

function getSelectedYear(){
  const range = document.getElementById('yearRange');
  const input = document.getElementById('yearInput');
  const v = clampYear(parseInt(input.value || range.value,10));
  const safe = v!=null? v : state.years.min;
  range.value = safe;
  input.value = safe;
  return safe;
}

function clampYear(v){
  if(!Number.isFinite(v)) return null;
  const min = parseInt(document.getElementById('yearRange').min,10);
  const max = parseInt(document.getElementById('yearRange').max,10);
  if(v<min) return min;
  if(v>max) return max;
  return v;
}

function niceStep(maxVal){
  if(maxVal<=0) return 1;
  const magnitude = Math.pow(10, Math.floor(Math.log10(maxVal)));
  const norm = maxVal / magnitude;
  if(norm<=2) return magnitude/2;
  if(norm<=5) return magnitude;
  return magnitude*2;
}

// Старт
loadAll();
</script>
</body>
</html>
